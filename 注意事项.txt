最新思路:

端口处提示sending,send failed,ready.
短信列表处显示 not sent,send failed.还要显示发送失败的端口,便于统计是哪个端口的问题.

发送失败的短信,则需重发.那么就需要把已经发送成功的短信从list 中移除....;这个并发支持吗??


问题是怎么提示呢??











整体构思:
每个端口一个线程,每个端口有自己内部独立的命令队列.在应用程序启动之后,所有端口默认启动各自的线程.各个端口的线程从各自的命令队列中获取命令并执行.
如果队列为空则线程阻塞.也就是说队列为阻塞队列.

用执行器组合端口和命令队列,还有端口的线程.

上层只需要创建执行器就可以了.

1.cmd 用一个抽象方法,实现名利组合.
2.阻塞队列
3.自建线程池


Q:
返回的命令不匹配:时间上,不同线程上.
如何确保命令和返回结果的匹配呢?

有写入就有返回,这个返回假如没有包含对这个输入的反应则如何?!!!!!!!!!,就是不知道readString 到底返回多少字符串.
ctrl+z 不会触发端口的监听器吗?
//和上个方法相比,只是有一行不同,怎么去掉代码的重复?
private ExecuteResult stream(Command cmd) throws Exception 

/dev/ttyXRUSB* 没权限时没有提示
第一次扫描时不能识别端口状态


1.由于每个端口一个线程,如果ATCommandExecutor 中的execute(String cmdContent) 执行后,如果监听器没有执行,则会导致这个线程阻塞.

2.分两种命令执行器,一种是独立的,一种是共享的的.


共享还是独立,有传进来的List 决定.如果传进来的是new List().addAll(list) 那就相当于独立了.即端口执行的命令队列是传进来的,而不是在内部new.
所以共享还是独立,由传进来的list 决定.

2.每个端口都有自己的命令队列.执行器是调用执行每个端口的名利.

线程如何和端口绑定??


